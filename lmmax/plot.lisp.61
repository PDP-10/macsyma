;;; -*- mode:lisp; package:macsyma; Lowercase:t; -*-b
;;; MACSYMA Plotting/Graphics Package for the LISP Machine

(macsyma-module plot)

;;; Todo:  plot options needs total rehack.
;;;        flush special declares

(declare (special $float $numer $ratprint $title $txtype $typel $window $xfun $xlabel
		  $yfun $ylabel &3d $plotnum $plotnum0 $plotnum1 $clear
		  $contours $noprint $plotnumprec $howclose $plots $ticknum $ticksize
		  $wait $xaxis $xfun $yaxis $yfun char-height char-width
		  max-x max-y min-x min-y plot-size plot-opts plot-vals
		  plot-window sameflg firstflg lastflg savemarks scale-x scale-y
		  size-x size-xf size-y size-yf tekplt-opts tekplt-vals
		  x-arrv y-arrv z-arrv $xmax $xmin $ymax $ymin $equalscale $viewpt
		  $centerplot $reverse $underside $loadprint $myoptions $values
		  dontflg vertflg sideflg $perspective $xmax1 $xmin1 $ymax1
		  $ymin1 $zmax1 $viewpt1 $centerplot1 $zmax1 $zmin1 $xmax3d $xmin3d
		  $ymax3d $ymin3d $zmax3d $zmin3d $window1 $dateplot $labelcontours
		  $float2bf $plotheight linel $ploterror plot-^] lisperrprint
		  user-timesofar $plotgap $crclear $plotundefined print-mode
                  vint sqr dasharray symbolarray print-dasharray print-symbolarray))

(DEFVAR $plotundefined "** Undefined Value **")

(defun setopt (plotvar plotval)
   (cond ((boundp plotvar)
          (cond ((memq plotvar (cdr $values))
                 (delq plotvar $values 1)
                 (add2lnc plotvar $myoptions))))
         (t (set plotvar plotval))))

(defun $plotinit nil
   (setq plot-opts
         '($perspective $ticksize $ticknum $underside $plotnum1 $plotnumprec
           $reverse $equalscale $noprint $plotnum $xaxis $yaxis
	   $contours $xfun $yfun $crosshatch $labelcontours $dateplot
	   $ploterror $plotgap $crclear)
         plot-vals
         '(t 6. 10. t 20. 4.
	   nil nil nil 20. $all $all
	   20. nil nil t t nil
	   t 20. t))
   (mapc 'setopt plot-opts plot-vals)
   (setq firstflg nil lastflg nil sameflg nil)
   (setq plot-window (list 0. 0. 1023. 1023.)
         plot-size (list 0.0 0.0 1023.0 1023.0))
   (setq vint (make-array nil 'art-q '(4))
         sqr (make-array nil 'art-q '(3))
         x-arrv (make-array nil 'art-q '(1))
         y-arrv (make-array nil 'art-q '(1))
         z-arrv (make-array nil 'art-q '(1))))

($plotinit)

;; This is a real Lisp Machine window.  Only one wired in for now.

(defun $plotreset nil 
   (mapc 'set plot-opts plot-vals)
   (setq firstflg nil lastflg nil sameflg nil dontflg nil
         vertflg nil sideflg nil)
   (mapc #'(lambda (x) (cond ((boundp x)
			      (and (memq x (cdr $values)) (delq x $values 1))
			      (makunbound x))))
         '($xmin $xmax $ymin $ymax $zmax $zmin $window $viewpt
                 $centerplot $plotnum0))
   (setq plot-window (get-window))                
   '$done)

(defun fmeval (y)
   (let ((x (cond ((eq $ploterror t) (meval y)) 
                  (t (setq y (cdr (let ((lisperrprint nil))
				    (meval `(($errcatch) ,y))
                                       )))
                     (cond (y (car y))
                           ((null $ploterror) $plotundefined)
                           (t $ploterror))))))
        (cond ((fixp x) (float x))
              ((floatp x) x)
              (($bfloatp x) ($float x))
              ((eq $ploterror t)
               (let (($ploterror y))
                    (displa (list '(mequal) y x))
                    (error '|which is not floating pt.|)))
              (t (float $ploterror)))))
			      
(defun fmeval1 (x)
   (cond ((fixp (setq x (meval x))) (float x))
         (($bfloatp x) ($float x))
         (t x)))

;;; Plot-^] is the user-timesofar handler.
(defun plot-^] () (setq plot-^] t))

;;; Pl^] does the printout for timesofar.
(defun pl^] (fun valu valu1)
   (setq plot-^] nil)
   (princ '|Plot: calculating |)
   (cond ((atom fun) (princ fun)) (t (princ '|f|)))
   (princ '|(|)
   (princ valu)
   (cond (valu1 (princ '|,|) (princ valu1)))
   (princ '|)/
|))

(defun arraychk (x i) 
   (and (arrayp x) (= (length (array-dimensions x)) i)))

#-LISPM
(defun funcallable (x)
  (cond ((symbolp x)
	 (fboundp x))
	((listp x) (eq (car x) 'lambda))
	('otherwise
	 ())))

#+LISPM
(deff funcallable 'functionp)

(defun range-comp (funl arrv l num) 
   (let ((arg3 (car l)) (high 0.0) (low 0.0) (inc 0.0) (xlen 0.)
         (intflg) (logflg) (logsgn -1.0) (var) ($ploterror t))
      (cond ((and (do ((l funl (cdr l)))
                      ((null l) t)
                     (cond ((not (funcallable (car l)))
                            (return nil))))
                  (or (numberp (fmeval1 arg3))
                      ($listp arg3)
                      (arraychk arg3 1.)))
             (setq l (cdr l)))
            (t (setq var arg3 arg3 (cadr l) l (cddr l))))
      (cond ((not (numberp (setq arg3 (fmeval1 arg3))))
             (cond ((arraychk arg3 1.) (setq xlen (car (array-dimensions arg3))))
                   (($listp arg3)
                    (setq arg3 (mapcar 'fmeval (cdr arg3)) 
                          xlen (length arg3)))
                   (t (displa arg3) (error '|Invalid arg to PLOT|)))
             (setq arrv (adjust-array-size arrv xlen))
             (fillarray arrv arg3))
            (t (cond ((null l) (error '|Too few args to PLOT|)))
               (cond ((< num 2.) (setq num 2.)))
               (setq high (fmeval (car l)) low arg3 l (cdr l))
               (cond ((eq (cond (l (car l))) '$integer)
                      (setq intflg t l (cdr l)))
                     ((or (memq '%log l) (memq '$loglin l))
                      (setq logflg t)))
               (cond (intflg
                      (cond ((< high low)
                             (setq inc -1.0
                                   low (float (fix low))
                                   high (float (- (fix (-$ high))))))
                            (t (setq inc 1.0
                                     high (float (fix high)) 
                                     low (float (- (fix (-$ low)))))))))
               (cond (logflg (cond ((< (*$ high low) 0.0)
                                    (displa (list '(mlist) low high))
                                    (error '|Invalid args to PLOT|)))
                             (cond ((> (+$ high low) 0.0)
                                    (setq logsgn 1.0)))
                             (setq high (cond ((= high 0.0) -90.0)
                                              (t (log (abs high))))
                                   low (cond ((= low 0.0) -90.0)
                                             (t (log (abs low)))))))
               (cond ((not intflg) (setq inc (-$ high low))))
               (cond (intflg (setq xlen (1+ (fix (//$ (-$ high low) inc))))
                             (cond ((< xlen 0) (setq xlen 1.))))
                     (t (setq xlen num)))
               (setq arrv (adjust-array-size arrv xlen))
               (do ((i 0. (1+ i))
                    (fcal (//$ (float (1- num))))
                    (val low
                         (cond (intflg (+$ val inc))
                               (t (+$ low (*$ inc (float (1+ i)) fcal))))))
                   ((= i xlen))
                   (cond (logflg (setq val (*$ logsgn (exp val)))))
                   (aset val arrv i))))
      (list var xlen l intflg)))

(defmspec $plot (l) (setq l (cdr l))
    (cond ((< (length l) 3.) (error '|Too few args to PLOT|)))
       (let ((funl (cond ((atom (car l)) (meval (car l)))
			 (t (car l))))
	     (var) ($numer t) ($float t) ($float2bf t) (intflg) ($ratprint)
	     (xlen 0.) (ylen 0.) (user-timesofar (cons 'plot-^] user-timesofar))
	     (plot-^]))
	  (setq l (cdr l) 
                funl (cond (($listp funl) (cdr funl)) (t (list funl))) 
                l (range-comp funl x-arrv l (fix $plotnum))
                var (car l)
                xlen (cadr l)
                intflg (cadddr l) 
                l (caddr l) 
                ylen (length funl))
          (adjust-array-size y-arrv (* xlen ylen))
          (do ((i 0. (1+ i)) (val))
              ((= i xlen))
             (setq val (aref x-arrv i))
             (do ((j 0. (1+ j)) (funl funl (cdr funl)))
                 ((= j ylen))
                (cond (plot-^] (pl^] (car funl) val nil)))
                (aset (cond (var (fmeval (list '($ev) (car funl)
                                               (list '(mequal) var
                                                     (cond (intflg (fix val))
                                                           (t val))))))
                            (t (funcall (car funl)
                                        (cond (intflg (fix val))
                                              (t val)))))
                      y-arrv (+ (* j xlen) i))))
          (adjust-array-size z-arrv 1.)
          (aset 0.0 z-arrv 0)
          (graph (do ((funl nil) (j (1- ylen) (1- j)))
                      ((< j 0.) funl)
                     (setq funl
                           (cons (list xlen 0. (* xlen j) 0. 1. 1. 0.) funl)))
                  (graphopts l nil))))

(defmspec $plot3d (l) (setq l (cdr l))
   (cond ((< (length l) 5.) (error '|Too few args to PLOT3D|)))
   (let ((funl (cond ((atom (car l)) (meval (car l)))
                     (t (car l))))
         (var) (var1) ($numer t) ($float t) ($float2bf t) (intflg) (intflg1)
         ($ratprint) (xlen 0.) (ylen 0.) (zlen 0.)
         (user-timesofar (cons 'plot-^] user-timesofar))
         (plot-^]))
      (setq funl (cond (($listp funl) (cdr funl)) (t (list funl))) 
            l (range-comp funl x-arrv (cdr l)
                          (cond ((numberp (meval1 '$plotnum0))
                                 (fix $plotnum0))
                                (t (fix $plotnum)))) 
            var (car l)
            xlen (cadr l)
            intflg (cadddr l) 
            l (caddr l) 
            l (range-comp funl y-arrv l (fix $plotnum1)) 
            var1 (cond ((null var) nil) (t (car l)))
            ylen (cadr l)
            intflg1 (cadddr l) 
            l (caddr l) 
            zlen (length funl))
      (setq z-arrv (adjust-array-size z-arrv (* xlen ylen zlen)))
      (do ((k 0. (1+ k)) (val1))
          ((= k ylen))
         (setq val1 (aref y-arrv k))
         (do ((i 0. (1+ i)) (val))
             ((= i xlen))
            (setq val (aref x-arrv i))
            (do ((j 0. (1+ j)) (funl funl (cdr funl)))
                ((= j zlen))
               (cond (plot-^] (pl^] (car funl) val val1)))
               (aset (cond (var
                            (fmeval (list '($ev) (car funl)
                                          (list '(mequal) var
                                                (cond (intflg (fix val))
                                                      (t val)))
                                          (list '(mequal)
                                                var1
                                                (cond (intflg1 (fix val1))
                                                      (t val1))))))
                           (t (funcall (car funl)
                                       (cond (intflg (fix val)) (t val))
                                       (cond (intflg1 (fix val1))
                                             (t val1)))))
                     z-arrv (+ (* k xlen zlen) (* j xlen) i)))))
      (graph (do ((funl nil) (k (1- zlen) (1- k)))
                  ((< k 0.) funl)
                 (setq funl (cons (list nil xlen ylen 0. 0. 0. (* xlen k)
                                        1. 1. 1. (* zlen xlen))
                                  funl)))
              (graphopts (cons '$hide l) nil))))

(defmspec $contourplot (form)
  (meval `(($plot3d) ,@(cdr form) $contour)))

(defmspec $paramplot (l)
  (setq l (cdr l))
   (cond ((< (length l) 4.) (error '|Too few args to PARAMPLOT|)))
   (let ((funlx (cond ((atom (car l)) (meval (car l)))
                      (t (car l))))
         (funly (cond ((atom (cadr l)) (meval (cadr l)))
                      (t (cadr l))))
         (var) ($numer t) ($float t) ($float2bf t) (intflg) ($ratprint)
         (xlen 0.) (ylen 0.) (zlen 0.)
         (user-timesofar (cons 'plot-^] user-timesofar))
         (plot-^]))
       (setq l (cddr l) 
             funlx (cond (($listp funlx) (cdr funlx)) (t (list funlx))) 
             funly (cond (($listp funly) (cdr funly)) (t (list funly))))
       (setq l (range-comp (append funlx funly) z-arrv l (fix $plotnum)) 
             var (car l) zlen (cadr l)
             intflg (cadddr l) 
             l (caddr l) 
             xlen (length funlx) 
             ylen (length funly))
       (adjust-array-size x-arrv (* xlen zlen))
       (adjust-array-size y-arrv (* ylen zlen))
       (do ((i 0. (1+ i)) (val))
           ((= i zlen))
          (setq val (aref z-arrv i))
          (do ((j 0. (1+ j)) (funlx funlx (cdr funlx)))
              ((= j xlen))
             (cond (plot-^] (pl^] (car funlx) val nil)))
             (aset (cond (var 
                          (fmeval (list '($ev)
                                        (car funlx)
                                        (list '(mequal)
                                              var
                                              (cond (intflg (fix val))
                                                    (t val))))))
				 (t (funcall (car funlx)
					     (cond (intflg (fix val))
						   (t val)))))
                   x-arrv (+ (* j zlen) i)))
          (do ((j 0. (1+ j)) (funly funly (cdr funly)))
              ((= j ylen))
             (cond (plot-^] (pl^] (car funly) val nil)))
             (aset (cond (var
                          (fmeval (list '($ev)
                                        (car funly)
                                        (list '(mequal)
                                              var
                                              (cond (intflg (fix val))
                                                    (t val))))))
                         (t (funcall (car funly)
                                     (cond (intflg (fix val))
                                           (t val)))))
                   y-arrv (+ (* j zlen) i))))
       (adjust-array-size z-arrv 1.)
       (aset 0. z-arrv 0)
       (graph (do ((funlx nil)
                    (j (1- (max xlen ylen)) (1- j))
                    (xlen (1- xlen))
                    (ylen (1- ylen)))
                   ((< j 0.) funlx)
                  (setq funlx (cons (list zlen
                                          (* zlen (min j xlen))
                                          (* zlen (min j ylen))
                                          0. 1. 1. 0.)
                                    funlx)))
               (graphopts l nil))))

(defun arg-comp (arg1 arrv) 
   (let ((xnum 0.) (xlen 0.) (funlx))
        (cond ((arraychk arg1 1.)
               (setq xlen (cadr (arraydims arg1)) 
                     xnum 1. 
                     funlx (list (list xlen 0.)))
               (adjust-array-size arrv xlen)
               (fillarray arrv arg1))
              ((arraychk arg1 2.)
               (setq xlen (car (array-dimensions arg1)) 
                     xnum (cadr (array-dimensions arg1))
                     funlx (do ((i (1- xnum) (1- i)) (funlx nil))
                               ((< i 0.) funlx)
                              (setq funlx
                                    (cons (list xlen (* i xlen)) funlx))))
               (adjust-array-size arrv (* xnum xlen))
               (fillarray arrv arg1))
              (($listp arg1)
               (setq arg1 (cdr arg1))
               (cond ((or (numberp (fmeval1 (car arg1)))
                          (eq (car arg1) '$same)
                          (eq (car arg1) '$integer))
                      (setq arg1 (list (cons '(mlist) arg1)))))
               (setq xnum (length arg1))
               (do ((i 0. (1+ i)) (arg1 arg1 (cdr arg1)) (j 0.) (l))
                   ((= i xnum))
                  (setq l (car arg1))
                  (cond ((arraychk l 1.)
                         (setq xlen (car (array-dimensions l)) 
                               funlx (cons (list xlen j) funlx))
                         (adjust-array-size arrv (+ j xlen))
                         (setq l (get l 'array))
                         (do ((k 0. (1+ k))) ((= k xlen))
                            (aset (aref l k) arrv j)
                            (setq j (1+ j))))
                        (($listp l)
                         (setq l (cdr l) xlen (length l) 
                               funlx (cons (list xlen j) funlx))
                         (adjust-array-size arrv (+ j xlen))
                         (do ((k 0. (1+ k)) (l l (cdr l)))
                             ((= k xlen))
                            (aset (fmeval (car l)) arrv j)
                            (setq j (1+ j))))
                        (t (displa l)
                           (error '|Invalid arg to GRAPH|))))
               (setq funlx (nreverse funlx)))
              (t (displa arg1) (error '|invalid arg to graph|)))
        funlx)) 

(defmspec $graph (l) (setq l (cdr l))
   (let ((funlx) (funly) ($numer t) ($float t) ($float2bf t))
      (setq funlx (arg-comp (meval (car l)) x-arrv)
            funly (arg-comp (meval (cadr l)) y-arrv))
      (setq l (cddr l))
      (adjust-array-size z-arrv 1.)
      (aset 0.0 z-arrv 0)
      (graph (do ((i (max (length funlx) (length funly)) (1- i))
                   (l1)
                   (funlx funlx
                          (cond ((null (cdr funlx)) funlx) (t (cdr funlx))))
                   (funly funly
                          (cond ((null (cdr funly)) funly) (t (cdr funly)))))
                  ((= i 0.) (nreverse l1))
                 (setq l1 (cons (list (min (caar funlx) (caar funly))
                                      (cadar funlx)
                                      (cadar funly)
                                      0. 1. 1. 0.)
                                l1)))
              (graphopts l nil))))

(defmspec $graph3d (l) (setq l (cdr l))
   (let ((funlx) (funly) (funlz) ($numer t) ($float t) ($float2bf t))
      (setq funlx (arg-comp (meval (car l)) x-arrv)
            funly (arg-comp (meval (cadr l)) y-arrv)
            funlz (arg-comp (meval (caddr l)) z-arrv))
      (setq l (cdddr l))
      (graph (do ((i (max (length funlx) (length funly)) (1- i))
                   (l1)
                   (funlx funlx
                          (cond ((null (cdr funlx)) funlx) (t (cdr funlx))))
                   (funly funly
                          (cond ((null (cdr funly)) funly) (t (cdr funly))))
                   (funlz funlz
                          (cond ((null (cdr funlz)) funlz) (t (cdr funlz)))))
                  ((= i 0.) (nreverse l1))
                 (setq l1 (cons (list (min (caar funlx) (caar funly)
                                           (caar funlz))
                                      (cadar funlx) (cadar funly)
                                      (cadar funlz) 1. 1. 1.)
                                l1)))
              (graphopts (cons '&3d l) nil))))

(defun graphopts (l oldl)
   (setq l (mapcar #'(lambda (el)
			     (cond ((null el) '$false)
				   ((memq el '($first $last $not3d $contour
						      &3d $same $false $polar %log
						      $loglin $linlog $lin $none
						      $hide $special $loglog
						      $top $bottom $left $right))
				    el)
				   (t (labeleval el))))
                   l))
   (setq firstflg nil lastflg nil sameflg nil dontflg nil
         vertflg nil sideflg nil)
   (prog (3d typel oxlabel oylabel otitle txtyp)
      (cond (oldl (setq 3d (car oldl) typel (cadr oldl) oxlabel (caddr oldl)
                        oylabel (cadddr oldl) otitle (car (cddddr oldl))
                        txtyp (cadr (cddddr oldl)))))
      (return (do ((l l (cdr l)) (l1) (xlabel) (ylabel) (title))
                  ((null l)
                   (setq typel (mapcar #'(lambda (el)
						 (cond ((fixp (meval el))
							(meval el))
						       (t el)))
                                       typel))
                   (cond ((null typel) (setq typel '((mlist) 0.))))
                   (cond ((eq txtyp '$lin) (setq txtyp nil)))
                   (append (list 3d typel)
                           (mapcar #'(lambda (el oel)
					     (cond ((eq el '$none) nil)
						   ((or (null el)
							(eq el '$false))
						    oel)
						   (t el)))
                                   (list xlabel ylabel title)
                                   (list oxlabel oylabel otitle))
                           (list txtyp)))
                 (setq l1 (car l))
                 (cond ((eq l1 '$first) (setq firstflg t lastflg nil))
                       ((eq l1 '$last) (setq lastflg t firstflg nil))
                       ((eq l1 '&3d) (setq 3d t))
                       ((eq l1 '$hide) (setq 3d '$hide))
                       ((eq l1 '$not3d) (setq 3d nil txtyp '$not3d))
                       ((eq l1 '$contour) (setq 3d '$contour))
                       ((eq l1 '$same) (setq sameflg t))
                       ((eq l1 '$dont) (setq dontflg t))
                       ((memq l1 '($top $bottom)) (setq vertflg l1))
                       ((memq l1 '($left $right)) (setq sideflg l1))
                       ((eq l1 '$loglog) (setq txtyp '%log))
                       ((memq l1
                              '($polar %log $loglin $linlog $lin $special))
                        (setq txtyp l1))
                       (($listp l1) (setq typel l1))
                       (xlabel (cond (ylabel (setq title l1))
                                     (t (setq ylabel l1))))
			       (t (setq xlabel l1)))))))

(defun labeleval (el)
   (cond ((or (atom el) (memq (caar el) '($ev $concat mquote $label)))
          (setq el (errset (meval el)))
          (cond ((null el) (print '|Error in evaluating label|)
                           '$false)
                (t (car el))))
         (t el)))

(defmspec $label (l) (setq l (cdr l))
       (setq l (mapcar #'(lambda (el)
				 (cond ((eq (caar el) 'mquote) (list (cdr el) '/ ))
				       (t (let ((el1 (meval el)) (el* el) (same nil))
					       (setq same (funcall '$is `(((mequal) ,el* ,el1))))
					       (if (floatp el1)
						   (setq el1
							 (format nil `((F ,(fix $plotnumprec)))
								 el1)))
					       (cond (same (list el1 '/ ))
						     (t (list el '= el1 '/ )))))))
		       l)
	     l (apply 'append l)
	     l (nreverse (cdr (nreverse l)))
	     l (mapcar #'(lambda (el) (cond ((atom el) (string* el))
					    (t (string el))))
		       l)
	     l (cons '& (apply 'append l)))
       (maknam l))
       
(defun graph (marks opts) 
   (prog (l $typel $xlabel $ylabel $title three-d $txtype CMD)
         (setq three-d (car opts) $typel (cadr opts) $xlabel (caddr opts)
               $ylabel (cadddr opts) opts (cddddr opts) $title (car opts)
               $txtype (cadr opts))
         (or (cdr $typel) (setq $typel '((mlist simp) 0.)))
         (and firstflg (setq $clear t $wait nil))
         (and lastflg (setq $wait t))
	 (setq savemarks (list marks
                               (list three-d $typel $xlabel $ylabel $title $txtype)))
	 (COND ((NOT DONTFLG)
		(cond ((and (not (or (eq three-d t) (eq three-d '$hide)))
			    (or (eq $xaxis '$all) (eq $yaxis '$all) (not $noprint)
				$labelcontours))))
		(cond ((eq three-d '$contour)
		       (contour-set $contours (meval1 '$zmin) (meval1 '$zmax))))
		(setfuns three-d $txtype (meval1 '$xfun) (meval1 '$yfun)
			 (meval1 '$centerplot))
		(setq cmd (if (not (memq '$PRESS (cdr $plotmode)))
			      (graph-internal marks three-d)
			      (graph-press-internal marks three-d)))))
	 (setq sameflg nil dontflg nil vertflg nil sideflg nil)
         (and firstflg (setq $clear nil firstflg nil))
         (and lastflg (setq $clear t lastflg nil))
	 (return (if cmd ($PLOT_COMMAND CMD) '$DONE))))

(defun graph-internal (marks three-d)
  (if $clear ($INITGRAPH))	;get display up
  ($entergraph)			;enter graphing mode
  (unwind-protect
    (progn
      (doscales marks three-d $xlabel $ylabel $title)
      (cond ((or (null three-d) (eq three-d t)) (graph2d marks (cdr $typel)))
	    ((eq three-d '$hide) (hide-drive marks (cdr $typel)))
	    ((eq three-d '$contour) (contour-drive marks (cdr $typel))))
      ($exitgraph))
    ($endgraph)))

(defvar $plot_press_file nil)

(defun graph-press-internal (marks three-d &aux cmd)
  (or $plot_press_file
      (merror "No output filename supplied for plotting to a press file."))
  ($entergraph)
  (press:bind-press-variables
    (unwind-protect
      (progn
	(press:press-start-file (filenamel $plot_press_file))
	(press:press-define-font-fake "fix" "" 10. 0)
	;; Only one font always, and it's font zero
	(press:press-open-page)
	(press:press-open-entity)
	(press:press-select-font 0)
	(let ((char-width (fifth (first press:press-font-list)))
	      (char-height (sixth (first press:press-font-list)))
	      ($wait nil)
	      (plot-stream 'graph-press-plot-stream))
	  (doscales marks three-d $xlabel $ylabel $title)
	  (cond ((or (null three-d) (eq three-d t)) (graph2d marks (cdr $typel)))
		((eq three-d '$hide) (hide-drive marks (cdr $typel)))
		((eq three-d '$contour) (contour-drive marks (cdr $typel))))
	  (setq cmd ($exitgraph)))
	(press:press-close-entity)
	(press:press-close-page)
	(press:press-end-file "Macsyma Plot" (TIME:PRINT-CURRENT-TIME NIL)))
      (funcall press:press-eftp-stream ':close ':abort)))
  cmd)

(defconst *press-height* (* 11. 2540.))

(defselect graph-press-plot-stream
  (:size ()
   (values (* 7. 2540.) *press-height*))
  (:get-plotting-range ()
   (multiple-value-bind (width height)
       (graph-press-plot-stream ':size)
     (if (> width height) (let ((x-off (// (- width height) 2)))
			    (list x-off 0 (+ x-off height) height))
	 (let ((y-off (// (- height width) 2)))
	   (list 0 y-off width (+ y-off width))))))
  (:draw-point (x y)
   (press:press-maybe-new-entity)
   (press:press-set-cursor x (- *press-height* y))
   (press:press-show-rect 1 1))
  (:draw-line (x0 y0 x1 y1)
   (press:press-line x0 (- *press-height* y0) x1 (- *press-height* y1)))
  (:current-font () nil)
  (:draw-char (ignore char x y)
   (press:press-maybe-new-entity)
   (press:press-set-cursor x (- *press-height* y char-height))
   (press:press-char char)))

(defun graph2d (marks typel)
   (do ((typel1 typel (cdr typel1)) (mark) (type))
       ((null marks))
      (or typel1 (setq typel1 typel))
      (setq mark (car marks) type (car typel1))
      (or (car mark)
          (setq marks (append (surf-expand mark t) (cdr marks))
                mark (car marks)))
      (let ((runl (car mark))
            (xlen (cadr mark))
            (ylen (caddr mark))
            (zlen (cadddr mark))
            (xinc 0.) (yinc 0.) (zinc 0.)
            (symtype (\ (// type 10.) 10.))
            (rept (1+ (\ (// type 100.) 100.)))
            (cnt (// type 10000.)))
         (setq mark (cddddr mark) xinc (car mark)
               yinc (cadr mark) zinc (caddr mark))
         (cond ((= rept 99.) (setq rept (1- runl)))
               ((= rept 100.) (setq rept runl)))
         (setq cnt (\ cnt rept) type (\ type 10.))
         ($changedash type)
         (cond ((not (and (eq (aref dasharray type) t) ;skip if line type [9]
                          (or (not display-mode)
                              (zerop (aref print-dasharray type)))
                          (null (aref symbolarray symtype))
                                   (or (not display-mode)
                              (zerop (aref print-symbolarray symtype)))))
                ($setpoint3 (aref x-arrv xlen) (aref y-arrv ylen) (aref z-arrv zlen))
                (cond ((and (> symtype 0.) (= cnt 0.))
                       ($drawsymbol3 (aref x-arrv xlen) (aref y-arrv ylen)
                                     (aref z-arrv zlen) symtype)))
                (do ((k 1. (1+ k))
                     (i (+ xinc xlen) (+ xinc i))
                     (j (+ yinc ylen) (+ yinc j))
                     (m (+ zinc zlen) (+ zinc m))
                     (prev-point t)
                     (x-point 0.0)
                     (y-point 0.0)
                     (z-point 0.0))
                    ((= k runl))
                   (setq x-point (aref x-arrv i) y-point (aref y-arrv j)
                         z-point (aref z-arrv m)
                         cnt (\ (1+ cnt) rept))
                   (cond ((or (eq x-point $plotundefined)
                              (eq y-point $plotundefined)
                              (eq z-point $plotundefined))
                          (setq prev-point nil))
                         (t (cond (prev-point
                                   ($vector3 x-point y-point z-point)
                                   (cond ((and (> symtype 0.) (= cnt 0.))
                                          ($drawsymbol3 x-point y-point
                                                        z-point symtype))))
                                  (t ($setpoint3 x-point y-point z-point)
                                     (setq prev-point t)))))))))
      (setq marks (cdr marks))))

(defun surf-expand (mark flg)
   (setq mark (cdr mark))
   (let ((xlen (car mark))
         (ylen (cadr mark))
         (xstart (cadddr mark))
         (ystart 0.) (zstart 0.) (xinc 0.) (yinc 0.) (zinc1 0.) (zinc2 0.))
      (setq mark (cddddr mark) ystart (car mark) zstart (cadr mark)
            xinc (caddr mark) yinc (cadddr mark) mark (cddddr mark)
            zinc1 (car mark) zinc2 (cadr mark))
      (do ((l) (i 0. (1+ i)))
         ((cond (flg (= i ylen)) (t (= i xlen))) (nreverse l))
         (cond (flg (setq l (cons (list xlen xstart (+ ystart (* yinc i))
                                        (+ zstart (* zinc2 i)) xinc 0. zinc1)
                                  l)))
               (t (setq l (cons (list ylen (+ xstart (* xinc i)) ystart
                                      (+ zstart (* zinc1 i)) 0. yinc zinc2)
                                l)))))))

(defun setfuns (3d txtyp xfun yfun cp)
   (cond ((eq txtyp '$special))
         ((not (or 3d txtyp)) (setq xfun nil yfun nil))
         ((or (eq 3d t) (eq 3d '$hide))
          (cond ((null cp)
                 (cond ($perspective
                        (cond ($reverse (setq xfun '$old3dxr yfun '$old3dyr))
                              (t (setq xfun '$old3dx yfun '$old3dy)))
                        (setq $howclose '$howcloseold3d))
                       (t (cond ($reverse
                                 (setq xfun '$oldnp3dxr yfun '$oldnp3dyr))
                                (t (setq xfun '$oldnp3dx yfun '$oldnp3dy)))
                          (setq $howclose '$howcloseoldnp3d))))
                (t (cond ($perspective
                          (cond ($reverse (setq xfun '$p3dxr yfun '$p3dyr))
                                (t (setq xfun '$p3dx yfun '$p3dy)))
                          (setq $howclose '$howclose3d))
                         (t (cond ($reverse (setq xfun '$np3dxr yfun '$np3dyr))
                                  (t (setq xfun '$np3dx yfun '$np3dy)))
                            (setq $howclose '$howclosenp3d))))))
         ((eq txtyp '$polar) (setq xfun '$polarx yfun '$polary))
         ((eq txtyp '%log) (setq xfun '$clog yfun '$clog))
         ((eq txtyp '$loglin) (setq xfun '$clog yfun nil))
         ((eq txtyp '$not3d) (setq yfun '$ztoy xfun nil))
         ((eq txtyp '$linlog) (setq yfun '$clog xfun nil)))
   (call-init xfun yfun)
   nil)

(defun date (long-form)
  (let ((date (errset (if long-form (TIME:print-current-date nil)
			  (TIME:print-current-time NIL)) NIL)))
    (if date (car date) "")))

(defun dolabels (3d xlabel ylabel title)
   (cond (sameflg
          ($screensize (- (car plot-window)
                          (cond (ylabel (* 2. char-width)) (t 0.)))
                       (- (cadr plot-window)
                          (cond (xlabel (* 2. char-height)) (t 0.)))
                       (caddr plot-window)
                       (+ (cadddr plot-window)
                          (cond ((or title (and (not sameflg) $dateplot))
                                 (* 2. char-height)) (t 0.)))))
         (t (apply '$screensize (get-window))))
   (cond (title ($ghprint (cond ((atom title) title)
                                (t (maknam (makstring title))))
                          (// (+ min-x max-x) 2.)
                          (- max-y char-height) 11.)))
   (cond ((and (not sameflg) $dateplot)
          ($ghprint (date (or (< (- (third plot-window) (first plot-window)) 300.)
			      (not title)))
		    max-x (- max-y char-height) 2.)))
   (cond ((or title (and (not sameflg) $dateplot))
          (setq max-y (- max-y (* 2. char-height)))))
   (cond ((not (or sameflg $noprint (or (eq 3d '$hide) (eq 3d t))))
          ((lambda (l)
              ($ghprint (cond ((< (* (length l) char-width) (- max-x min-x))
                               (maknam l))
                              (t (list (format nil `((f ,(fix $plotnumprec)))
					       (car plot-size))
                                       '/ 
                                       (format nil `((f ,(fix $plotnumprec)))
					       (caddr plot-size))
                                       '/ 
				       (format nil `((f ,(fix $plotnumprec)))
					       (cadr plot-size))
                                       '/ 
                                       (format nil `((f ,(fix $plotnumprec)))
					       (cadddr plot-size)))))
                        (// (+ min-x max-x) 2.) min-y 1.))
           (apply 'append
                  (mapcar 'exploden
                          (list '|Xmin = |
                                (format nil `((f ,(fix $plotnumprec)))
					       (car plot-size))
                                '|  Xmax = |
				(format nil `((f ,(fix $plotnumprec)))
					       (caddr plot-size))
                                '|  Ymin = |
				(format nil `((f ,(fix $plotnumprec)))
					       (cadr plot-size))
                                '|  Ymax = |
				(format nil `((f ,(fix $plotnumprec)))
					       (cadddr plot-size))))))
          (setq min-y (+ min-y char-height))))
   (cond (xlabel ($ghprint (cond ((atom xlabel) xlabel)
                                 (t (maknam (makstring $xlabel))))
                           (// (+ min-x max-x) 2.)
                           min-y 1.)
                 (setq min-y (+ min-y char-height))))
   (cond ((or xlabel (not $noprint)) (setq min-y (+ min-y char-height))))
   (cond (ylabel ($gvprint (cond ((atom ylabel) ylabel)
                                 (t (maknam (makstring ylabel))))
                           min-x
                           (// (+ min-y max-y) 2.)
                           1.)
                 (setq min-x (+ min-x (* 2. char-width)))))
   (or sameflg (setq plot-window (list min-x min-y max-x max-y)))
   (apply '$screensize plot-window))

(defun get-window nil
   (let ((window (cond (($listp (meval1 '$window))
			(mapcar 'fix (list (cadr $window) (cadddr $window) (caddr $window)
					   (car (cddddr $window)))))
		       (t (GET-PLOTTING-RANGE))))
	 (mn-x 0) (mn-y 0) (mx-x 0) (mx-y 0) (cx 0) (cy 0) (gap 0))
	(cond ((null (or vertflg sideflg)) window)
	      (t (setq mn-x (car window) mn-y (cadr window)
		       mx-x (caddr window) mx-y (cadddr window)
		       cx (// (+ mn-x mx-x) 2) cy (// (+ mn-y mx-y) 2)
		       gap (// (fix $plotgap) 2))
		 (cond (vertflg (cond ((eq vertflg '$top)
				       (setq mn-y (+ cy gap)))
				      (t (setq mx-y (- cy gap))))))
		 (cond (sideflg (cond ((eq sideflg '$left)
				       (setq mx-x (- cx gap)))
				      (t (setq mn-x (+ cx gap))))))
		 (list mn-x mn-y mx-x mx-y)))))

(defun doscales (marks 3d xlabel ylabel title)
 ($changedash 0.)
 (let ((l) (l1))
      (cond ((not sameflg)
	     (and (or (eq 3d t) (eq 3d '$hide))
		  (3d-scale (meval1 '$centerplot) (meval1 '$viewpt)))
	     (setq l (scale0 marks (meval1 '$xmin) (meval1 '$xmax)
			     #'call-x)
		   l (apply 'scale1
			    (cons (cond ((or (eq 3d t) (eq 3d '$hide)) 0.)
					((atom $ticknum)
					 (fix $ticknum))
					(t (fix (cadr $ticknum))))
				  l)))
	     (setq l1 (scale0 marks (meval1 '$ymin) (meval1 '$ymax)
			      #'call-y)
		   l1 (apply 'scale1
			     (cons (cond ((or (eq 3d t) (eq 3d '$hide)) 0.)
					 ((atom $ticknum)
					  (fix $ticknum))
					 (t (fix (caddr $ticknum))))
				   l1)))
	     (setq plot-size (list (caddr l) (caddr l1) (cadddr l)
				   (cadddr l1)))))
      (dolabels 3d xlabel ylabel title)
      (apply '$size plot-size)
      (setq $xmin1 (car plot-size) $ymin1 (cadr plot-size)
	    $xmax1 (caddr plot-size) $ymax1 (cadddr plot-size))
      (cond ((and (not sameflg) $equalscale)
	     (cond ((> scale-y scale-x)
		    (setq plot-window
			  (list (+ min-x
				   (fix (//$ (-$ (float size-x)
						 (//$ size-xf scale-y)) 2.0)))
				min-y
				(- max-x
				   (fix (//$ (-$ (float size-x)
				 (//$ size-xf scale-y)) 2.0)))
				max-y)))
		   (t
		    (setq plot-window
			  (list min-x
				(+ min-y
				   (fix (//$ (-$ (float size-y)
						 (//$ size-yf scale-x)) 2.0)))
				max-x
				(- max-y (fix (//$ (-$ (float size-y)
						       (//$ size-yf scale-x))
						   2.0)))))))
	     (apply '$screensize plot-window)))
      (setq $window1 (list '(mlist) (car plot-window) (caddr plot-window)
			   (cadr plot-window) (cadddr plot-window)))
      (cond ((not (or sameflg (eq 3d t) (eq 3d '$hide)))
	     (apply 'axes (append l l1))))))

(defun 3d-scale (cp vp)
       (let ((cpflg (and (listp cp)
                         (listp (car cp))
                         (eq (caar cp) 'mlist)
			 (numberp (cadr cp))
			 (numberp (caddr cp))
			 (numberp (cadddr cp))))
	     (vpflg (and (listp vp)
                         (listp (car vp))
                         (eq (caar vp) 'mlist)
			 (numberp (cadr vp))
			 (numberp (caddr vp))
			 (numberp (cadddr vp)))))
	    (cond ((not (and cpflg vpflg))
		   (do ((arrs (list z-arrv y-arrv x-arrv) (cdr arrs))
			(arr)
			(lmin)
			(lmax)
			(infin 1.e300))
		       ((null arrs)
			(cond (vpflg (setq vp (mapcar 'float (cdr vp))))
			      (t (setq vp (mapcar
					   #'(lambda (max min)
						     (+$ (cond ($perspective max)
							       (t 0.0))
							 (*$ 3.0 (-$ max min))))
					   lmax lmin))))
			(cond (cpflg (setq cp (mapcar 'float (cdr cp))))
			      (t (cond ((null cp)
					(setq cp (list (car vp)
						       (*$ 0.5 (+$ (cadr lmax)
								   (cadr lmin)))
						       (caddr vp))))
				       (t (setq cp (mapcar
						    #'(lambda (max min)
							      (*$ 0.5 (+$ max min)))
						    lmax lmin))))))
			(setq $xmin3d (car lmin) $ymin3d (cadr lmin)
			      $zmin3d (caddr lmin) $xmax3d (car lmax)
			      $ymax3d (cadr lmax) $zmax3d (caddr lmax))
			nil)
		       (setq arr (car arrs))
		       (do ((i 0. (1+ i)) (max (-$ infin)) (min infin)
					  (len (car (array-dimensions arr))) (pt))
			   ((= i len) (setq lmin (cons min lmin) lmax (cons max lmax))
				      nil)
			   (setq pt (aref arr i))
			   (and (> pt max) (setq max pt))
			   (and (< pt min) (setq min pt)))))
		  (t (setq vp (mapcar 'float (cdr vp)) cp (mapcar 'float (cdr cp)))))
	    (apply '$initperspec (append cp vp))
	    (setq $centerplot1 (cons '(mlist) cp) $viewpt1 (cons '(mlist) vp))
	    nil))

(defun scale0 (marks l l1 call-fun) 
       (let ((infin 1.e300)
	     (xmin 0.0)
	     (xmax 0.0))
	    (cond ((not (and (numberp l) (numberp l1)))
		   (setq xmin infin xmax (-$ infin))
		   (do ((marks marks (cdr marks)) (mark) (len)
						  (xbeg) (ybeg) (zbeg))
		       ((null marks))
		       (setq mark (car marks))
		       (or (car mark)
			   (setq marks (append (surf-expand mark t) (cdr marks))
				 mark (car marks)))
		       (setq len (car mark) xbeg (cadr mark)
			     ybeg (caddr mark) zbeg (cadddr mark)
			     mark (cddddr mark))
		       (do ((xinc (car mark))
			    (yinc (cadr mark))
			    (zinc (caddr mark))
			    (pt)
			    (i 0 (1+ i))
			    (x-pt 0.0) (y-pt 0.0) (z-pt 0.0) )
			   ((= i len))
			   (declare (flonum x-pt y-pt z-pt))
			   (setq x-pt (aref x-arrv xbeg)
				 y-pt (aref y-arrv ybeg)
				 z-pt (aref z-arrv zbeg))
			   (cond ((not (or (eq x-pt $plotundefined)
					   (eq y-pt $plotundefined)
					   (eq z-pt $plotundefined)))
				  (setq pt (funcall call-fun x-pt y-pt z-pt))
				  (and (> pt xmax) (setq xmax pt))
				  (and (< pt xmin) (setq xmin pt))))
			   (setq xbeg (+ xbeg xinc) ybeg (+ ybeg yinc)
				 zbeg (+ zbeg zinc))))))
	    (and (numberp l) (setq xmin (float l)))
	    (and (numberp l1) (setq xmax (float l1)))
	    (cond ((< xmax xmin) (setq xmax (prog2 nil xmin (setq xmin xmax)))))
	    (cond ((= xmax xmin)
		   (cond ((= xmax 0.0) (setq xmax 1.0 xmin -1.0))
			 (t (setq xmax (+$ xmax (*$ (abs xmax) 0.1)) 
				  xmin (-$ xmin (*$ (abs xmin) 0.1)))))))
	    (list xmin xmax))) 

(defun scale1 (n xmin xmax) 
       (cond ((not (= n 0))
	      (fillarray vint '(1.0 2.0 5.0 10.0))
	      (do ((i 0. (1+ i)))
		  ((> i 2.))
		  (aset (sqrt (*$ (aref vint i) (aref vint (1+ i)))) sqr i))
	      (let ((del 2.0e-5) (a 0.0) (b 0.0) (xminp 0.0) (xmaxp 0.0)
		    (dist 0.0)
		    (sign (> n 0.)))
		   (setq n (abs n)
			 a (//$ (-$ xmax xmin) (float n))
			 n (fix (//$ (log a) (log 10.0))) 
			 b (//$ a (float (my-^$ 10. n))))
		   (do ((i 0. (1+ i)))
		       ((> i 2.) (setq b (aref vint 3.)))
		       (cond ((< b (aref sqr i)) (return (setq b (aref vint i))))))
		   (setq dist (*$ b (my-^$ 10. n)) a (//$ xmin dist) n (fix a))
		   (and (< (abs (-$ (float (1+ n)) a)) del) (setq n (1+ n)))
		   (setq xminp (*$ dist (float n)) a (//$ xmax dist)
			 n (1+ (fix a)))
		   (and (< (abs (-$ a (float (1- n)))) del) (setq n (1- n)))
		   (setq xmaxp (*$ dist (float n)))
		   (and (> xminp xmin) (setq xminp xmin))
		   (and (< xmaxp xmax) (setq xmaxp xmax))
		   (or sign (cond ((< (+$ xminp (*$ dist del)) xmin)
				   (setq xminp (+$ xminp dist)))))
		   (and sign (setq xmin xminp xmax xmaxp))
		   (list xminp dist xmin xmax)))
	     (t (list xmin (-$ xmax xmin) xmin xmax))))


(defun my-^$ (x n)
   (exp (* (log x) n)))

(defun axis (xlow xhigh xminp xdist org horiz) 
       (let ((ft (cond ((atom $ticksize) (float $ticksize))
		       (horiz (float (cadr $ticksize)))
		       (t (float (caddr $ticksize)))))
	     (del 2.0e-5))
	    (cond (horiz ($line xlow org xhigh org) (setq ft (*$ ft scale-y)))
		  (t ($line org xlow org xhigh) (setq ft (*$ ft scale-x))))
	    (and (> ft 0.0) (> xdist 0.0)
		 (setq ft (prog2 nil (+$ org ft) (setq org (-$ org ft))))
		 (do ((xminp xminp (+$ xminp xdist))
		      (xmaxp (+$ (*$ del xdist) xhigh)))
		     ((> xminp xmaxp))
		     (cond (horiz ($line xminp org xminp ft))
			   (t ($line org xminp ft xminp))))))) 

(defun axes (xminp xdist xmin xmax yminp ydist ymin ymax) 
  (let ((org 0.0))
    (cond ($xaxis (cond ((or (< ymax 0.0) (> ymin 0.0)) (setq org ymin))
			(t (setq org 0.0)))
		  (axis xmin xmax xminp xdist org t)
		  (cond ((eq $xaxis '$all)
			 ($ghprint (format nil `((f ,(fix $plotnumprec))) xmin)
				   (plot-x xmin) (- (plot-y org) char-height)
				   0.)
			 ($ghprint (format nil `((f ,(fix $plotnumprec))) xmax)
				   (plot-x xmax) (- (plot-y org) char-height)
				   2.)))))
    (cond ($yaxis (cond ((or (< xmax 0.0) (> xmin 0.0)) (setq org xmin))
			(t (setq org 0.0)))
		  (axis ymin ymax yminp ydist org nil)
		  (cond ((eq $yaxis '$all)
			 ($ghprint (format nil `((f ,(fix $plotnumprec))) ymin)
				   (plot-x org) (plot-y ymin) 2.)
			 ($ghprint (format nil `((f ,(fix $plotnumprec))) ymax)
				   (plot-x org) (plot-y ymax) 2.)))))))

(defmspec $replot (l1) (setq l1 (cdr l1))
	  (let ((l2 (cond ((atom (car l1))
			   (cond (($listp (meval1 (car l1)))
				  (cdr (meval1 (car l1))))
				 (t (list (car l1)))))
			  (($listp (car l1)) (cdar l1))
			  (t (list (car l1))))))
	    (do ((l2 l2 (cdr l2)) (l)) ((null l2) '$done) (setq l (car l2))
		(cond ((or (null l) (eq l 't) (eq l '$true)) (setq l savemarks))
		      (t (cond ((setq l (plotp l t))
				(setq l (cdr l))
				(adjust-array-size x-arrv (car (array-dimensions (car l))))
				(fillarray x-arrv (car l))
				(setq l (cdr l))
				(adjust-array-size y-arrv (car (array-dimensions (car l))))
				(fillarray y-arrv (car l))
				(setq l (cdr l))
				(adjust-array-size z-arrv (car (array-dimensions (car l))))
				(fillarray z-arrv (car l))
				(setq l (cdr l)))
			       ((eq (car (setq l (meval1 (car l2)))) 'this-is-a-plot)
				(setq l (cdr l))
				(adjust-array-size x-arrv  (length (car l)))
				(fillarray x-arrv (car l))
				(setq l (cdr l))
				(adjust-array-size y-arrv (length (car l)))
				(fillarray y-arrv (car l))
				(setq l (cdr l))
				(adjust-array-size z-arrv (length (car l)))
				(fillarray z-arrv (car l))
				(setq l (cdr l)))
			       (t (displa (quote-subs (car l2)))
				  (error '|not a plot|)))))
		(apply 'graph (list (car l) (graphopts (cdr l1) (cadr l)))))))

(defun apply-$replot (l) (meval `(($replot) ,@l)))

(defmspec $replot4 (l) (setq l (cdr l))
       (cond ((> (length l) 4.) (error '|Too many args to REPLOT4|)))
       (let ((l1 (get-window))
	     (mn-x 0.) (mx-x 0.) (mn-y 0.) (mx-y 0.) (cx 0.) (cy 0.)
	     (datel (list nil $dateplot nil nil)))
	    (setq mn-x (car l1) mn-y (cadr l1) mx-x (caddr l1) mx-y (cadddr l1))
	    (setq cx (// (+ mn-x mx-x) 2.) cy (// (+ mn-y mx-y) 2.))
	    (setq l1 (list (list mn-x (- cx 10.) (+ cy 5.) mx-y)
			   (list (+ cx 10.) mx-x (+ cy 5.) mx-y)
			   (list mn-x (- cx 10.) mn-y (- cy 5.))
			   (list (+ cx 10.) mx-x mn-y (- cy 5.))))
	    (do ((l l (cdr l))
		 (flag '$first '$false)
		 ($window (cons '(mlist) (car l1)) (cons '(mlist) (car l1)))
		 ($dateplot (cond ((null (cdr l)) $dateplot)
				  (t (car datel)))
			    (car datel)))
		((null (cdr l)) (apply-$replot (list (car l) '$last)))
		(setq l1 (cdr l1) datel (cdr datel))
		(apply-$replot (list (car l) flag)))))

(if (not (boundp '$plots)) (setq $plots '((mlist))))


(defun quote-subs (pval)
       (cond ((atom pval) pval)
	     ((memq 'array (cdar pval))
	      (cons (car pval)
		    (mapcar #'(lambda (l)
				      (setq l (meval l))
				      (cond ((numberp l) l)
					    (t (list '(mquote) l))))
			    (cdr pval))))
	     (t pval)))

(defmspec $nameplot (pval) (setq pval (cdr pval))
       (or (= (length pval) 1.) (error '|Wrong number of args to NAMEPLOT|))
       (setq pval (quote-subs (car pval)))
       (mset pval nil)					; test for error here
;      (cond ((member pval $plots) (killplot pval)))
       (let ((l savemarks) (ary))
	    (setq ary (make-array nil 'art-q (car (array-dimensions z-arrv))))
	    (fillarray ary z-arrv)
	    (setq l (cons ary l)
		  ary (make-array nil 'art-q (car (array-dimensions y-arrv))))
	    (fillarray ary y-arrv)
	    (setq l (cons ary l)
		  ary (make-array nil 'art-q (car (array-dimensions x-arrv))))
	    (fillarray ary x-arrv)
	    (mset pval (cons (list 'plot-/#2 'simp) (cons ary l)))
	    (nconc $plots (ncons pval))
	    pval))


(defun plotp (l1 reload)
       (let ((pval (meval1 l1)))
	    (cond ((and (eq (typep pval) 'list) (eq (caar pval) 'plot-/#2))
		   (cond ((> (length pval) 4.)
			  pval)
			 ((and reload (eq (typep (cddar pval)) 'list)
			       (= (length (cddar pval)) 3.))
			  (loadplots (cddar pval) t (memq $loadprint '(t $autoload)))
			  (plotp l1 nil)))))))


